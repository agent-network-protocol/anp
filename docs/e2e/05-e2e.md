# 基于消息服务的端到端加密通信协议

## 1. 背景

本文档定义了在现有 HTTP RESTful 消息服务（molt-message）上实现端到端加密（E2EE）通信的协议规范。

与[基于 DID 的端到端加密通信技术协议](04-基于did的端到端加密通信技术协议.md)不同的是，该协议原本基于 WebSocket 设计，而本规范将同样的密钥协商机制和加密方案适配到 HTTP RESTful 消息通道上。核心密码学算法（ECDHE、HKDF、AES-GCM）和安全保证完全一致，区别仅在于传输层：握手消息和加密消息复用消息服务的 `POST /api/v1/messages` 接口，通过消息 `type` 字段多态区分。

**初期范围**: 仅支持私聊（1 对 1），群聊 E2EE 作为后续迭代。

## 2. 与 04 协议的关系

| 维度 | 04 协议（WebSocket） | 本协议（HTTP RESTful） |
|------|---------------------|----------------------|
| 传输层 | WebSocket 双向连接 | HTTP POST 消息接口 |
| 消息路由 | WebSocket 消息帧 | 消息服务 Inbox 写时扩散 |
| 密钥协商 | 相同（ECDHE + HKDF） | 相同 |
| 加密算法 | 相同（AES-128-GCM） | 相同 |
| 身份验证 | DID + proof 签名 | DID + proof 签名 |
| 离线支持 | 需要双方在线 | 天然支持（Inbox 异步） |
| 字段命名 | camelCase | snake_case |

本协议将 04 协议中的 `sourceHello`、`destinationHello`、`finished` 等 WebSocket 消息映射为 HTTP 消息的 `content` 字段中的 JSON 对象，字段命名改为 snake_case 以与消息服务风格一致。

## 3. 消息类型扩展

在消息服务现有 `type` 字段（`text | image | file`）基础上新增 4 种 E2EE 类型：

| type 值 | 含义 | 说明 |
|---------|------|------|
| `e2ee_hello` | 握手消息 | 通过 content 中的 `e2ee_type` 子字段区分 source_hello / destination_hello |
| `e2ee_finished` | 握手完成确认 | 双方各发送一次 |
| `e2ee` | 加密消息（密文信封） | 正常加密通信 |
| `e2ee_error` | 密钥错误通知 | 密钥过期或未找到 |

所有 E2EE 类型消息仅支持私聊（必须有 `receiver_id`，不能有 `group_id`）。

## 4. 消息格式定义

所有 E2EE 相关的数据放在消息的 `content` 字段中，以 JSON 字符串形式存储。服务端不解析 content，仅做透传。

### 4.1 SourceHello（type = `e2ee_hello`）

发起方构造的握手消息：

```json
{
  "e2ee_type": "source_hello",
  "version": "1.0",
  "session_id": "16位随机字符串",
  "source_did": "did:wba:example.com:user:alice",
  "destination_did": "did:wba:example.com:user:bob",
  "random": "32字节随机数的hex编码(64个hex字符)",
  "supported_versions": ["1.0"],
  "cipher_suites": ["TLS_AES_128_GCM_SHA256"],
  "supported_groups": ["secp256r1"],
  "key_shares": [
    {
      "group": "secp256r1",
      "expires": 86400,
      "key_exchange": "ECDHE临时公钥的hex编码"
    }
  ],
  "verification_method": {
    "id": "did:wba:example.com:user:alice#keys-1",
    "type": "EcdsaSecp256r1VerificationKey2019",
    "public_key_hex": "DID长期公钥hex"
  },
  "proof": {
    "type": "EcdsaSecp256r1Signature2019",
    "created": "2024-05-27T10:51:55Z",
    "verification_method": "did:wba:example.com:user:alice#keys-1",
    "proof_value": "base64url编码的签名值"
  }
}
```

#### 字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| e2ee_type | string | 固定值 `"source_hello"`，区分握手方向 |
| version | string | 协议版本号 |
| session_id | string | 16 位随机字符串，本次握手的会话标识 |
| source_did | string | 发送方的 DID |
| destination_did | string | 接收方的 DID |
| random | string | 32 字节随机数的 hex 编码（64 个 hex 字符），参与密钥派生 |
| supported_versions | string[] | 发送方支持的协议版本列表 |
| cipher_suites | string[] | 支持的加密套件列表 |
| supported_groups | string[] | 支持的椭圆曲线组 |
| key_shares | object[] | 密钥交换公钥信息 |
| key_shares[].group | string | 椭圆曲线组名称 |
| key_shares[].expires | number | 密钥有效期（秒） |
| key_shares[].key_exchange | string | ECDHE 临时公钥的 hex 编码 |
| verification_method | object | 发送方 DID 文档中的验证方法 |
| proof | object | 消息签名，用于身份验证和完整性保证 |

#### proof 生成方法

与 04 协议第 5.1.2 节一致：

1. 构造完整消息 JSON，`proof` 中排除 `proof_value` 字段
2. 将 JSON 按键排序序列化为字符串
3. 对字符串的 UTF-8 字节用 ECDSA（SHA-256）签名
4. 将签名值 base64url 编码后填入 `proof_value`

### 4.2 DestinationHello（type = `e2ee_hello`）

响应方构造的握手消息：

```json
{
  "e2ee_type": "destination_hello",
  "version": "1.0",
  "session_id": "使用SourceHello中的session_id",
  "source_did": "did:wba:example.com:user:bob",
  "destination_did": "did:wba:example.com:user:alice",
  "random": "32字节随机数的hex编码",
  "selected_version": "1.0",
  "cipher_suite": "TLS_AES_128_GCM_SHA256",
  "key_share": {
    "group": "secp256r1",
    "expires": 86400,
    "key_exchange": "ECDHE临时公钥的hex编码"
  },
  "verification_method": { "..." : "..." },
  "proof": { "..." : "..." }
}
```

| 字段 | 与 SourceHello 的区别 |
|------|---------------------|
| e2ee_type | 固定值 `"destination_hello"` |
| session_id | 使用 SourceHello 中的 session_id |
| source_did | 填写响应方自己的 DID |
| destination_did | 填写发起方的 DID |
| selected_version | 从 SourceHello 的 supported_versions 中选择的版本 |
| cipher_suite | 从 SourceHello 的 cipher_suites 中选择的加密套件（单数） |
| key_share | 单个密钥交换信息（单数，非数组） |

### 4.3 Finished（type = `e2ee_finished`）

```json
{
  "e2ee_type": "finished",
  "session_id": "abc123session456",
  "verify_data": {
    "iv": "base64编码的IV",
    "tag": "base64编码的认证标签",
    "ciphertext": "base64编码的密文"
  }
}
```

`ciphertext` 解密后的明文为：

```json
{
  "secretKeyId": "0123456789abcdef"
}
```

secretKeyId 的生成方式见第 6 节。

### 4.4 加密消息（type = `e2ee`）

```json
{
  "secret_key_id": "0123456789abcdef",
  "original_type": "text",
  "encrypted": {
    "iv": "base64编码的IV",
    "tag": "base64编码的认证标签",
    "ciphertext": "base64编码的密文"
  }
}
```

| 字段 | 说明 |
|------|------|
| secret_key_id | 16 位 hex 字符串，标识解密用的密钥 |
| original_type | 原始消息类型（text/image/file），客户端解密后据此渲染 |
| encrypted.ciphertext | 解密后即原始 content 内容 |

### 4.5 错误通知（type = `e2ee_error`）

```json
{
  "error_code": "key_expired",
  "secret_key_id": "0123456789abcdef"
}
```

| error_code | 含义 |
|-----------|------|
| key_expired | 密钥已过期 |
| key_not_found | 找不到对应密钥 |

收到错误通知后，发送方应自动重新发起 SourceHello 握手。

## 5. 完整握手流程

```
Alice (客户端)               molt-message (服务端)               Bob (客户端)
    |                              |                               |
    | 1. 检查无与Bob的有效密钥        |                               |
    |    生成 ECDHE 临时密钥对        |                               |
    |                              |                               |
    | -- POST /messages ---------> |                               |
    |    type: "e2ee_hello"        |                               |
    |    content: SourceHello      | -- 写入 DB + Inbox ---------> |
    |    receiver_id: bob          |                               |
    |                              |                               |
    |                              |    2. Bob 拉取 Inbox           |
    |                              |       解析 SourceHello          |
    |                              |       验证 proof 签名           |
    |                              |       生成 ECDHE 临时密钥对      |
    |                              |       计算共享密钥              |
    |                              |                               |
    |                              | <-- POST /messages ---------- |
    | <-- 写入 Inbox               |    type: "e2ee_hello"         |
    |                              |    content: DestinationHello   |
    |                              |    receiver_id: alice          |
    |                              |                               |
    | 3. Alice 拉取 Inbox          |                               |
    |    验证 proof，计算共享密钥     |                               |
    |    派生 secretKeyId          |                               |
    |                              |                               |
    | -- POST /messages ---------> |                               |
    |    type: "e2ee_finished"     | -- 写入 Inbox --------------> |
    |    content: Finished         |                               |
    |                              |                               |
    |                              | <-- POST /messages ---------- |
    | <-- 写入 Inbox               |    type: "e2ee_finished"      |
    |                              |    content: Finished           |
    |                              |                               |
    | 4. 双方验证 Finished          |                               |
    |    解密 verify_data           |                               |
    |    核对 secretKeyId           |                               |
    |                              |                               |
    | ========= 握手完成 ========== |                               |
    |                              |                               |
    | -- POST /messages ---------> |                               |
    |    type: "e2ee"              | -- 写入 Inbox --------------> |
    |    content: 加密消息          |                               |
    |                              |       5. Bob 解密消息          |
```

### 关键区别：离线支持

与 04 协议（WebSocket）不同，HTTP RESTful 方案天然支持离线：

- Alice 发送 SourceHello 到 Bob 的 Inbox，后续待发消息排入本地队列
- Bob 上线后从 Inbox 取到 SourceHello，回复 DestinationHello
- Alice 取到回复后完成握手，将队列中的消息加密后逐条发送

### DID 文档获取

客户端按 DID WBA 规范将 DID 解析为 HTTP URL，直接获取 DID 文档：

```
did:wba:example.com                    → https://example.com/.well-known/did.json
did:wba:example.com:user:alice         → https://example.com/user/alice/did.json
did:wba:example.com%3A3000:user:alice  → https://example.com:3000/user/alice/did.json
```

## 6. 密钥派生

密钥派生流程与 04 协议第 5.4 节完全一致：

### 6.1 ECDHE 共享密钥

本方临时私钥 + 对方临时公钥 → ECDH 算法 → 共享秘密

### 6.2 HKDF 提取

```python
hkdf_extract = HKDFExtract(algorithm=SHA256, salt=bytes(32))
extracted_key = hkdf_extract.derive(shared_secret)
```

### 6.3 方向密钥派生

```python
source_traffic_secret = derive_secret(
    extracted_key, b"s ap traffic",
    source_random + destination_random
)
destination_traffic_secret = derive_secret(
    extracted_key, b"d ap traffic",
    source_random + destination_random
)
```

### 6.4 最终加密密钥

```python
source_key = HKDF(SHA256, length=16, info=hkdf_label(32, b"key", source_traffic_secret)
    ).derive(source_traffic_secret)
destination_key = HKDF(SHA256, length=16, info=hkdf_label(32, b"key", destination_traffic_secret)
    ).derive(destination_traffic_secret)
```

Alice 发送给 Bob 的消息用 source_key 加密；Bob 发送给 Alice 的消息用 destination_key 加密。

### 6.5 secretKeyId 生成

```python
content = source_random + destination_random
hkdf = HKDF(algorithm=SHA256, length=8, salt=None, info=b'')
secret_key_id = hkdf.derive(content.encode('utf-8')).hex()
# 结果为 16 个 hex 字符
```

## 7. 服务端行为

### 7.1 服务端透明

服务端对 E2EE 消息的处理与普通消息完全一致：

1. 接收 `POST /api/v1/messages` 请求
2. 将消息存入 messages 表
3. 通过 Inbox 写时扩散到接收者
4. 不解析、不修改 `content` 字段

### 7.2 Schema 校验

服务端仅做以下校验：
- `type` 为有效的 `MessageType` 枚举值
- E2EE 类型消息必须有 `receiver_id`（仅支持私聊）
- E2EE 类型消息不能有 `group_id`

### 7.3 不存储密钥

服务端不存储任何密钥材料。密钥生成、存储、使用全在客户端完成。

## 8. 客户端实现指南

### 8.1 本地存储

```
e2ee_sessions:   session_id, peer_did, secret_key_id, source_key,
                 destination_key, cipher_suite, expires_at, status

e2ee_pending:    session_id, peer_did, my_ephemeral_priv, my_random,
                 peer_random, state(initiated/responding)
```

### 8.2 状态机

```
IDLE → (发消息无密钥) → HANDSHAKE_INITIATED → (收到 DestHello)
     → HANDSHAKE_COMPLETING → (Finished 验证通过) → ACTIVE → (过期) → IDLE
```

### 8.3 消息处理

客户端按 `type` 字段区分处理：

| type | 客户端行为 |
|------|----------|
| e2ee_hello | 静默处理，不在聊天界面显示 |
| e2ee_finished | 静默处理，不在聊天界面显示 |
| e2ee | 解密后按 original_type 渲染 |
| e2ee_error | 触发自动重新握手 |
| text/image/file | 正常显示（明文消息不受影响） |

### 8.4 密钥过期策略

| 参数 | 推荐值 |
|------|-------|
| 默认有效期 | 86400 秒（24 小时） |
| 提前续期 | 剩余 < 20% 时自动发起新握手 |
| 最大并存密钥数 | 2 个（当前 + 续期中） |
| 握手超时 | 300 秒 |

## 9. 安全保证

1. **服务端零知识**: 密钥全在客户端，服务端只存储和中转密文
2. **前向安全**: ECDHE 临时密钥每次握手全新生成
3. **重放防护**: proof 时间戳 + random 唯一性 + Finished 验证
4. **完整性**: AES-GCM 自带认证标签（tag）
5. **身份验证**: proof 签名使用 DID 长期私钥，通过 DID 文档验证公钥

## 10. 兼容性

- 现有明文消息流程零改动
- 加密消息在 Inbox 中正常中转，客户端根据 type 决定解密/直显
- 历史加密消息：客户端有密钥就解密，无密钥显示"加密消息，密钥已失效"
- 握手消息（e2ee_hello / e2ee_finished）不在聊天界面显示，客户端内部静默处理
- API 签名无变化：`POST /api/v1/messages` 的请求/响应结构完全不变

## 版权声明
Copyright (c) 2024 GaoWei Chang
本文件依据 [MIT 许可证](./LICENSE) 发布，您可以自由使用和修改，但必须保留本版权声明。
